"""
Generador de posts divulgativos estilo Medium
"""

import re
from typing import Optional, Dict, Any, List
from datetime import datetime
from pathlib import Path

from ..utils.logger import app_logger
from ..utils.config_loader import config_loader
from ..utils.database import Article


class PostGenerator:
    """Generador de posts divulgativos estilo Medium."""
    
    def __init__(self):
        """Inicializa el generador de posts."""
        self.config = config_loader.get_text_processing_config()
        self.max_post_length = self.config.get('max_post_length', 1500)
        self.casual_tone = self.config.get('casual_tone', True)
        
        # Plantillas para diferentes tipos de contenido
        self.templates = {
            'research_finding': [
                "¬øSab√≠as que {finding}? Un nuevo estudio ha revelado {details}.",
                "Los investigadores han hecho un descubrimiento fascinante: {finding}. {details}",
                "La ciencia nos sorprende una vez m√°s. {finding}, seg√∫n muestra {details}."
            ],
            'methodology': [
                "Los cient√≠ficos han desarrollado una nueva forma de {method}. {details}",
                "Una innovadora metodolog√≠a permite {method}. {details}",
                "¬øC√≥mo se puede {method}? Los investigadores han encontrado la respuesta: {details}"
            ],
            'application': [
                "Esta investigaci√≥n podr√≠a cambiar la forma en que {application}. {details}",
                "Las implicaciones de este estudio son enormes para {application}. {details}",
                "Imagina un futuro donde {application}. Este estudio nos acerca a esa realidad: {details}"
            ]
        }
    
    def generate_post(self, article: Article, summary: str = None) -> str:
        """
        Genera un post divulgativo estilo Medium.
        
        Args:
            article: Art√≠culo cient√≠fico
            summary: Resumen del art√≠culo (opcional)
            
        Returns:
            Post divulgativo generado
        """
        app_logger.info(f"Generando post para: {article.title[:50]}...")
        
        # Extraer informaci√≥n estructurada del art√≠culo
        structured_info = self._extract_article_information(article, summary)
        
        # Estructura del post
        post_sections = []
        
        # 1. T√≠tulo atractivo
        catchy_title = self._create_catchy_title(article.title, structured_info)
        post_sections.append(f"# {catchy_title}\n")
        
        # 2. Hook inicial espec√≠fico
        hook = self._create_specific_hook(structured_info)
        post_sections.append(f"{hook}\n")
        
        # 3. El problema que aborda
        if structured_info['problem']:
            post_sections.append(f"## El desaf√≠o\n\n{structured_info['problem']}\n")
        
        # 4. La metodolog√≠a (c√≥mo lo resolvieron)
        if structured_info['methodology']:
            post_sections.append(f"## C√≥mo lo abordaron\n\n{structured_info['methodology']}\n")
        
        # 5. Los hallazgos espec√≠ficos
        if structured_info['findings']:
            post_sections.append(f"## Lo que descubrieron\n\n{structured_info['findings']}\n")
        
        # 6. Los n√∫meros que importan
        if structured_info['key_metrics']:
            post_sections.append(f"## Los n√∫meros clave\n\n{structured_info['key_metrics']}\n")
        
        # 7. Por qu√© es importante
        implications = self._create_specific_implications(structured_info, article)
        if implications:
            post_sections.append(f"## Por qu√© importa\n\n{implications}\n")
        
        # 8. Conclusi√≥n espec√≠fica
        conclusion = self._create_specific_conclusion(structured_info)
        post_sections.append(f"## En resumen\n\n{conclusion}\n")
        
        # 9. Metadatos
        metadata = self._create_metadata_section(article)
        post_sections.append(f"---\n\n{metadata}")
        
        # Unir todas las secciones
        full_post = '\n'.join(post_sections)
        
        # Limitar longitud si es necesario
        if len(full_post.split()) > self.max_post_length:
            full_post = self._trim_post(full_post, self.max_post_length)
        
        app_logger.info(f"Post generado ({len(full_post.split())} palabras)")
        return full_post
    
    def _extract_article_information(self, article: Article, summary: str = None) -> Dict[str, str]:
        """
        Extrae informaci√≥n estructurada espec√≠fica del art√≠culo.
        
        Args:
            article: Art√≠culo cient√≠fico
            summary: Resumen del art√≠culo
            
        Returns:
            Diccionario con informaci√≥n estructurada
        """
        # Combinar todo el texto disponible
        combined_text = ""
        if article.abstract:
            combined_text += article.abstract + " "
        if article.full_text:
            combined_text += article.full_text + " "
        if summary:
            combined_text += summary
        
        info = {
            'problem': '',
            'methodology': '',
            'findings': '',
            'key_metrics': '',
            'conclusions': '',
            'research_area': self._identify_research_area(article)
        }
        
        if combined_text:
            # Usar el mismo extractor que el summarizer
            from .summarizer import ArticleSummarizer
            summarizer = ArticleSummarizer()
            structured_data = summarizer._extract_structured_information(article.abstract, article.full_text)
            
            # Adaptar la informaci√≥n para el post
            info['problem'] = self._format_problem_for_post(structured_data.get('problem', ''))
            info['methodology'] = self._format_methodology_for_post(structured_data.get('methodology', ''))
            info['findings'] = self._format_findings_for_post(structured_data.get('results', ''))
            info['key_metrics'] = self._format_metrics_for_post(structured_data.get('key_numbers', []))
            info['conclusions'] = structured_data.get('conclusions', '')
        
        return info
    
    def _format_problem_for_post(self, problem: str) -> str:
        """Formatea el problema para el post."""
        if not problem:
            return ""
        
        # Hacer m√°s conversacional
        if problem.startswith("Los investigadores abordaron"):
            problem = problem.replace("Los investigadores abordaron", "")
        
        return f"Los cient√≠ficos se enfrentaron a un desaf√≠o importante: {problem.strip()}. Este problema es crucial porque afecta directamente nuestra comprensi√≥n y capacidad de avanzar en el √°rea."
    
    def _format_methodology_for_post(self, methodology: str) -> str:
        """Formatea la metodolog√≠a para el post."""
        if not methodology:
            return ""
        
        return f"Para abordar este desaf√≠o, los investigadores {methodology}. Esta aproximaci√≥n les permiti√≥ obtener datos confiables y resultados reproducibles."
    
    def _format_findings_for_post(self, findings: str) -> str:
        """Formatea los hallazgos para el post."""
        if not findings:
            return ""
        
        # Hacer m√°s espec√≠fico y emocionante
        findings_formatted = findings
        if findings.startswith("Los resultados mostraron que"):
            findings_formatted = findings.replace("Los resultados mostraron que", "")
        
        return f"Los hallazgos fueron reveladores: {findings_formatted.strip()}. Estos resultados representan un avance significativo en nuestra comprensi√≥n del tema."
    
    def _format_metrics_for_post(self, metrics: List[str]) -> str:
        """Formatea las m√©tricas clave para el post."""
        if not metrics:
            return ""
        
        metrics_text = []
        for metric in metrics[:4]:  # M√°ximo 4 m√©tricas
            metrics_text.append(f"‚Ä¢ **{metric}**")
        
        intro = "Los n√∫meros hablan por s√≠ solos:" if len(metrics) > 1 else "El resultado clave:"
        return f"{intro}\n\n" + "\n".join(metrics_text)
    
    def _create_specific_hook(self, structured_info: Dict[str, str]) -> str:
        """
        Crea un hook espec√≠fico basado en la informaci√≥n del art√≠culo.
        
        Args:
            structured_info: Informaci√≥n estructurada del art√≠culo
            
        Returns:
            Hook espec√≠fico
        """
        # Usar los hallazgos m√°s impactantes para el hook
        if structured_info['findings']:
            return f"**{structured_info['findings'].split('.')[0]}.**\n\nEsto es lo que acaba de descubrir un equipo de investigadores, y las implicaciones podr√≠an cambiar nuestra perspectiva sobre el tema."
        
        elif structured_info['problem']:
            return f"**¬øQu√© pasar√≠a si pudi√©ramos resolver {structured_info['problem'].lower()}?**\n\nUn nuevo estudio nos acerca a esa posibilidad con resultados que superan las expectativas."
        
        else:
            return "**La ciencia acaba de darnos una nueva perspectiva sobre un problema complejo.**\n\nLos resultados de esta investigaci√≥n podr√≠an cambiar la forma en que entendemos y abordamos desaf√≠os importantes en el √°rea."
    
    def _create_specific_implications(self, structured_info: Dict[str, str], article: Article) -> str:
        """
        Crea implicaciones espec√≠ficas basadas en el contenido real del art√≠culo.
        
        Args:
            structured_info: Informaci√≥n estructurada
            article: Art√≠culo cient√≠fico
            
        Returns:
            Implicaciones espec√≠ficas
        """
        implications = []
        research_area = structured_info['research_area']
        
        # Implicaciones basadas en los hallazgos espec√≠ficos
        if structured_info['findings']:
            if research_area == 'bioinformatics':
                implications.append(f"üß¨ **Para la medicina personalizada**: {structured_info['findings']} podr√≠a llevar a tratamientos m√°s precisos y efectivos.")
            elif research_area == 'ai_ml':
                implications.append(f"ü§ñ **Para la inteligencia artificial**: {structured_info['findings']} abre nuevas posibilidades en automatizaci√≥n y toma de decisiones.")
            elif research_area == 'plant_microbe':
                implications.append(f"üå± **Para la agricultura**: {structured_info['findings']} podr√≠a mejorar la productividad y sostenibilidad de los cultivos.")
            else:
                implications.append(f"üî¨ **Para la investigaci√≥n**: {structured_info['findings']} establece nuevas bases para futuros estudios.")
        
        # Implicaciones basadas en la metodolog√≠a
        if structured_info['methodology']:
            implications.append(f"‚öôÔ∏è **Para la metodolog√≠a cient√≠fica**: La aproximaci√≥n utilizada ({structured_info['methodology']}) podr√≠a aplicarse a problemas similares en otras √°reas.")
        
        # Implicaciones basadas en las m√©tricas
        if structured_info['key_metrics']:
            implications.append(f"üìä **Para la evaluaci√≥n**: Las m√©tricas obtenidas establecen nuevos est√°ndares de referencia en el campo.")
        
        return '\n\n'.join(implications[:3])  # M√°ximo 3 implicaciones
    
    def _create_specific_conclusion(self, structured_info: Dict[str, str]) -> str:
        """
        Crea una conclusi√≥n espec√≠fica basada en el contenido del art√≠culo.
        
        Args:
            structured_info: Informaci√≥n estructurada
            
        Returns:
            Conclusi√≥n espec√≠fica
        """
        conclusion_parts = []
        
        # Resumir el impacto principal
        if structured_info['findings']:
            conclusion_parts.append(f"Este estudio demuestra que {structured_info['findings'].lower()}")
        
        # Mencionar la metodolog√≠a si es innovadora
        if structured_info['methodology'] and any(word in structured_info['methodology'].lower() for word in ['nuevo', 'innovador', 'primera vez', 'novel']):
            conclusion_parts.append(f"La metodolog√≠a utilizada ({structured_info['methodology']}) representa un avance metodol√≥gico importante")
        
        # Perspectiva futura
        research_area = structured_info['research_area']
        if research_area == 'bioinformatics':
            conclusion_parts.append("abriendo nuevas posibilidades para la medicina de precisi√≥n")
        elif research_area == 'ai_ml':
            conclusion_parts.append("marcando el camino hacia sistemas m√°s inteligentes y eficientes")
        elif research_area == 'plant_microbe':
            conclusion_parts.append("contribuyendo a una agricultura m√°s sostenible y productiva")
        else:
            conclusion_parts.append("estableciendo nuevas direcciones para la investigaci√≥n futura")
        
        if conclusion_parts:
            return '. '.join(conclusion_parts) + '.'
        else:
            return "Esta investigaci√≥n representa un paso importante hacia una mejor comprensi√≥n de los desaf√≠os complejos en su √°rea, con implicaciones que se extender√°n m√°s all√° del laboratorio."
    
    def _create_catchy_title(self, original_title: str, structured_info: Dict[str, str] = None) -> str:
        """
        Crea un t√≠tulo atractivo para el post.
        
        Args:
            original_title: T√≠tulo original del art√≠culo
            structured_info: Informaci√≥n estructurada del art√≠culo
            
        Returns:
            T√≠tulo atractivo
        """
        if not original_title:
            return "Un Descubrimiento Cient√≠fico Fascinante"
        
        # Usar informaci√≥n espec√≠fica si est√° disponible
        if structured_info and structured_info.get('findings'):
            # Crear t√≠tulo basado en los hallazgos
            findings = structured_info['findings']
            if 'reveladores' in findings:
                return f"üî¨ Revelaci√≥n: {self._simplify_title(original_title)}"
            elif any(word in findings.lower() for word in ['mejora', 'mejor', 'superior']):
                return f"üí° Breakthrough: {self._simplify_title(original_title)}"
            else:
                return f"üéØ Descubrimiento: {self._simplify_title(original_title)}"
        
        # Fallback al m√©todo original
        title_lower = original_title.lower()
        
        if any(term in title_lower for term in ['new', 'novel', 'first', 'nuevo', 'primera']):
            return f"üî¨ Breakthrough: {self._simplify_title(original_title)}"
        elif any(term in title_lower for term in ['improve', 'better', 'enhance', 'mejor', 'mejora']):
            return f"üí° Innovaci√≥n: {self._simplify_title(original_title)}"
        elif any(term in title_lower for term in ['discover', 'find', 'reveal', 'descubr', 'encontr']):
            return f"üéØ Descubrimiento: {self._simplify_title(original_title)}"
        elif any(term in title_lower for term in ['ai', 'machine learning', 'deep learning', 'inteligencia artificial']):
            return f"ü§ñ IA en Acci√≥n: {self._simplify_title(original_title)}"
        elif any(term in title_lower for term in ['plant', 'microbe', 'planta', 'microbio']):
            return f"üå± Naturaleza: {self._simplify_title(original_title)}"
        else:
            return f"üî¨ Ciencia: {self._simplify_title(original_title)}"

    def _identify_research_area(self, article) -> str:
        """
        Identifica el √°rea de investigaci√≥n del art√≠culo.
        
        Args:
            article: Art√≠culo cient√≠fico
            
        Returns:
            √Årea de investigaci√≥n identificada
        """
        text_to_analyze = f"{article.title} {article.abstract or ''}".lower()
        
        if any(term in text_to_analyze for term in ['bioinformatics', 'bioinform√°tica', 'computational biology', 'genomics']):
            return 'bioinformatics'
        elif any(term in text_to_analyze for term in ['machine learning', 'deep learning', 'ai', 'artificial intelligence']):
            return 'ai_ml'
        elif any(term in text_to_analyze for term in ['plant', 'microbe', 'planta', 'microbio', 'interaction']):
            return 'plant_microbe'
        elif any(term in text_to_analyze for term in ['education', 'educaci√≥n', 'teaching', 'learning']):
            return 'education'
        else:
            return 'general'
    
    def _simplify_title(self, title: str) -> str:
        """
        Simplifica un t√≠tulo t√©cnico.
        
        Args:
            title: T√≠tulo t√©cnico
            
        Returns:
            T√≠tulo simplificado
        """
        # Remover jerga muy t√©cnica
        simplified = title
        
        # Reemplazos comunes
        replacements = {
            'bioinformatics': 'an√°lisis de datos biol√≥gicos',
            'computational': 'computacional',
            'algorithm': 'm√©todo',
            'machine learning': 'aprendizaje autom√°tico',
            'deep learning': 'inteligencia artificial',
            'optimization': 'optimizaci√≥n',
            'analysis': 'an√°lisis'
        }
        
        for tech_term, simple_term in replacements.items():
            simplified = re.sub(tech_term, simple_term, simplified, flags=re.IGNORECASE)
        
        # Limitar longitud
        if len(simplified) > 80:
            simplified = simplified[:77] + "..."
        
        return simplified


    def _create_metadata_section(self, article) -> str:
        """
        Crea la secci√≥n de metadatos.
        
        Args:
            article: Art√≠culo cient√≠fico
            
        Returns:
            Secci√≥n de metadatos
        """
        metadata_parts = []
        
        # Informaci√≥n del art√≠culo
        metadata_parts.append(f"**üìÑ Art√≠culo original**: [{article.title}]({article.url})")
        
        # Autores
        if article.authors:
            authors_str = ', '.join(article.authors[:3])  # M√°ximo 3 autores
            if len(article.authors) > 3:
                authors_str += f" y {len(article.authors) - 3} m√°s"
            metadata_parts.append(f"**üë• Autores**: {authors_str}")
        
        # Fuente
        metadata_parts.append(f"**üîó Fuente**: {article.source}")
        
        # Fecha
        if hasattr(article, 'publication_date') and article.publication_date:
            date_str = article.publication_date.strftime("%B %Y")
            metadata_parts.append(f"**üìÖ Publicado**: {date_str}")
        
        # Temas
        if article.topics:
            topics_str = ', '.join(article.topics[:3])
            metadata_parts.append(f"**üè∑Ô∏è Temas**: {topics_str}")
        
        # Nota sobre divulgaci√≥n
        metadata_parts.append("**‚ÑπÔ∏è Nota**: Este es un resumen divulgativo. Para detalles t√©cnicos completos, consulta el art√≠culo original.")
        
        return '\n\n'.join(metadata_parts)

